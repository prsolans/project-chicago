-- HelloFriend Database Schema Migration
-- Creates tables for phrase library, usage tracking, and conversation history

-- ============================================
-- ENUMS
-- ============================================

CREATE TYPE phrase_category AS ENUM (
  'family',
  'medical',
  'comfort',
  'social',
  'responses',
  'questions'
);

CREATE TYPE time_of_day AS ENUM (
  'morning',
  'afternoon',
  'evening',
  'anytime'
);

CREATE TYPE phrase_source AS ENUM (
  'static',           -- Original hardcoded phrases
  'ai_generated',     -- Generated by AI predictions
  'user_typed',       -- Promoted from typed messages
  'user_custom'       -- Manually created by user
);

CREATE TYPE input_method AS ENUM (
  'typed',            -- Manually typed on keyboard
  'predicted',        -- Selected from AI predictions
  'category',         -- Selected from category phrases
  'quick_phrase',     -- Selected from quick phrases
  'starter',          -- Selected from starters
  'thought_stream'    -- From thought completion
);

CREATE TYPE candidate_status AS ENUM (
  'pending',          -- Detected but not yet reviewed
  'approved',         -- User approved to add to library
  'rejected'          -- User rejected
);

-- ============================================
-- TABLES
-- ============================================

-- Phrases table: stores all quick phrases
CREATE TABLE phrases (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  text TEXT NOT NULL,
  category phrase_category NOT NULL,
  time_of_day time_of_day DEFAULT 'anytime',
  source phrase_source NOT NULL DEFAULT 'static',
  confidence DECIMAL(3, 2) DEFAULT 0.9, -- For AI-generated phrases
  is_active BOOLEAN DEFAULT true,       -- Soft delete support
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  -- Prevent duplicate phrases
  CONSTRAINT unique_phrase_text UNIQUE (text)
);

-- Phrase usage tracking: logs every phrase selection
CREATE TABLE phrase_usage (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  phrase_id UUID REFERENCES phrases(id) ON DELETE CASCADE,
  used_at TIMESTAMPTZ DEFAULT NOW(),
  input_method input_method NOT NULL
);

-- Phrase candidates: detected phrases awaiting promotion
CREATE TABLE phrase_candidates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  text TEXT NOT NULL UNIQUE,
  first_seen TIMESTAMPTZ DEFAULT NOW(),
  last_used TIMESTAMPTZ DEFAULT NOW(),
  usage_count INTEGER DEFAULT 1,
  suggested_category phrase_category,
  status candidate_status DEFAULT 'pending',
  similarity_score DECIMAL(3, 2), -- Score against existing phrases (0-1)
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Conversation history: all messages sent by user
CREATE TABLE conversation_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  content TEXT NOT NULL,
  input_method input_method NOT NULL,
  phrase_id UUID REFERENCES phrases(id) ON DELETE SET NULL, -- Link if from phrase
  timestamp TIMESTAMPTZ DEFAULT NOW()
);

-- ============================================
-- INDEXES for Performance
-- ============================================

-- Phrases indexes
CREATE INDEX idx_phrases_category ON phrases(category);
CREATE INDEX idx_phrases_active ON phrases(is_active);
CREATE INDEX idx_phrases_source ON phrases(source);
CREATE INDEX idx_phrases_time_of_day ON phrases(time_of_day);

-- Usage tracking indexes
CREATE INDEX idx_phrase_usage_phrase_id ON phrase_usage(phrase_id);
CREATE INDEX idx_phrase_usage_used_at ON phrase_usage(used_at DESC);
CREATE INDEX idx_phrase_usage_method ON phrase_usage(input_method);

-- Candidates indexes
CREATE INDEX idx_candidates_status ON phrase_candidates(status);
CREATE INDEX idx_candidates_usage_count ON phrase_candidates(usage_count DESC);
CREATE INDEX idx_candidates_last_used ON phrase_candidates(last_used DESC);

-- Conversation history indexes
CREATE INDEX idx_conversation_timestamp ON conversation_history(timestamp DESC);
CREATE INDEX idx_conversation_method ON conversation_history(input_method);

-- ============================================
-- VIEWS for Common Queries
-- ============================================

-- Phrase usage statistics
CREATE VIEW phrase_stats AS
SELECT
  p.id,
  p.text,
  p.category,
  p.source,
  COUNT(pu.id) AS total_usage,
  MAX(pu.used_at) AS last_used,
  MIN(pu.used_at) AS first_used,
  COUNT(DISTINCT DATE(pu.used_at)) AS days_used,
  -- Usage in last 7 days
  COUNT(CASE WHEN pu.used_at > NOW() - INTERVAL '7 days' THEN 1 END) AS usage_last_7_days,
  -- Usage in last 30 days
  COUNT(CASE WHEN pu.used_at > NOW() - INTERVAL '30 days' THEN 1 END) AS usage_last_30_days
FROM phrases p
LEFT JOIN phrase_usage pu ON p.id = pu.phrase_id
WHERE p.is_active = true
GROUP BY p.id, p.text, p.category, p.source;

-- Top phrases by usage
CREATE VIEW top_phrases AS
SELECT
  ps.*,
  -- Weighted score: recent usage (70%) + total usage (30%)
  (ps.usage_last_7_days * 0.7 + ps.total_usage * 0.3) AS relevance_score
FROM phrase_stats ps
WHERE ps.total_usage > 0
ORDER BY relevance_score DESC
LIMIT 50;

-- Pending candidates ready for review
CREATE VIEW pending_candidates AS
SELECT
  pc.*,
  -- Days since first seen
  EXTRACT(DAY FROM (NOW() - pc.first_seen)) AS days_pending,
  -- Hours since last used
  EXTRACT(HOUR FROM (NOW() - pc.last_used)) AS hours_since_use
FROM phrase_candidates pc
WHERE pc.status = 'pending'
  AND pc.usage_count >= 3
  AND pc.last_used > NOW() - INTERVAL '7 days'
ORDER BY pc.usage_count DESC, pc.last_used DESC;

-- ============================================
-- FUNCTIONS
-- ============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to auto-update updated_at
CREATE TRIGGER update_phrases_updated_at
  BEFORE UPDATE ON phrases
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_candidates_updated_at
  BEFORE UPDATE ON phrase_candidates
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Function to track phrase usage
CREATE OR REPLACE FUNCTION track_phrase_usage(
  p_phrase_id UUID,
  p_input_method input_method
) RETURNS void AS $$
BEGIN
  INSERT INTO phrase_usage (phrase_id, input_method)
  VALUES (p_phrase_id, p_input_method);
END;
$$ LANGUAGE plpgsql;

-- Function to detect or update candidate phrase
CREATE OR REPLACE FUNCTION track_candidate_phrase(
  p_text TEXT,
  p_suggested_category phrase_category DEFAULT NULL
) RETURNS UUID AS $$
DECLARE
  v_candidate_id UUID;
BEGIN
  -- Try to update existing candidate
  UPDATE phrase_candidates
  SET
    usage_count = usage_count + 1,
    last_used = NOW(),
    suggested_category = COALESCE(p_suggested_category, suggested_category)
  WHERE text = p_text
  RETURNING id INTO v_candidate_id;

  -- If not found, insert new candidate
  IF v_candidate_id IS NULL THEN
    INSERT INTO phrase_candidates (text, suggested_category)
    VALUES (p_text, p_suggested_category)
    RETURNING id INTO v_candidate_id;
  END IF;

  RETURN v_candidate_id;
END;
$$ LANGUAGE plpgsql;

-- Function to promote candidate to phrase
CREATE OR REPLACE FUNCTION promote_candidate_to_phrase(
  p_candidate_id UUID,
  p_category phrase_category,
  p_time_of_day time_of_day DEFAULT 'anytime'
) RETURNS UUID AS $$
DECLARE
  v_phrase_id UUID;
  v_candidate_text TEXT;
BEGIN
  -- Get candidate text
  SELECT text INTO v_candidate_text
  FROM phrase_candidates
  WHERE id = p_candidate_id;

  IF v_candidate_text IS NULL THEN
    RAISE EXCEPTION 'Candidate not found';
  END IF;

  -- Insert as new phrase
  INSERT INTO phrases (text, category, time_of_day, source)
  VALUES (v_candidate_text, p_category, p_time_of_day, 'user_typed')
  RETURNING id INTO v_phrase_id;

  -- Mark candidate as approved
  UPDATE phrase_candidates
  SET status = 'approved'
  WHERE id = p_candidate_id;

  RETURN v_phrase_id;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================

-- For single-user app, we'll enable RLS but allow all operations
-- This provides security foundation for future multi-user support

ALTER TABLE phrases ENABLE ROW LEVEL SECURITY;
ALTER TABLE phrase_usage ENABLE ROW LEVEL SECURITY;
ALTER TABLE phrase_candidates ENABLE ROW LEVEL SECURITY;
ALTER TABLE conversation_history ENABLE ROW LEVEL SECURITY;

-- Allow all operations (single user, no auth required)
CREATE POLICY "Allow all on phrases" ON phrases FOR ALL USING (true);
CREATE POLICY "Allow all on phrase_usage" ON phrase_usage FOR ALL USING (true);
CREATE POLICY "Allow all on phrase_candidates" ON phrase_candidates FOR ALL USING (true);
CREATE POLICY "Allow all on conversation_history" ON conversation_history FOR ALL USING (true);

-- ============================================
-- COMMENTS
-- ============================================

COMMENT ON TABLE phrases IS 'Library of all quick phrases available to the user';
COMMENT ON TABLE phrase_usage IS 'Tracks every time a phrase is selected/spoken';
COMMENT ON TABLE phrase_candidates IS 'Frequently typed messages that could become quick phrases';
COMMENT ON TABLE conversation_history IS 'Complete history of all messages sent by user';

COMMENT ON VIEW phrase_stats IS 'Usage statistics for each phrase';
COMMENT ON VIEW top_phrases IS 'Top 50 phrases by relevance (recent + total usage)';
COMMENT ON VIEW pending_candidates IS 'Candidates ready for user review/promotion';
